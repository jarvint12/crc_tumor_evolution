Created: 04.05.2023 08:49:26
Model version: cnn_v1_4
Path: saved_models/cnn_v1_4.pth
Run name: None
Accuracy: 0.40926733115731695

Hyperparameters:
Optimizer: Adam
Learning rate: 0.0001
Weight decay: 0.0001
Used CrossEntropyLoss with label smoothing 0.0382
Balanced classes
Train batch size: 64
Validation batch size: 5


--------------------------Script of the model can be seen below.---------------------------
import torch
import torch.nn as nn
import torch.nn.functional as F

class cnn(nn.Module):
    def __init__(self, many_classes):
        super(cnn, self).__init__()
        # YOUR CODE HERE
        self.many_classes=many_classes
        self.dropout=nn.Dropout(0.3)
        self.m = nn.MaxPool1d(2, stride=2)
        self.norm0=nn.BatchNorm2d(21)
        #self.conv1 = nn.Conv1d(1, 6, (4,1))
        self.conv1 = nn.Conv1d(21, 25, (4,1))
        self.norm1=nn.BatchNorm1d(25)
        self.conv2 = nn.Conv1d(25, 12, 3)
        self.norm2=nn.BatchNorm1d(12)
        self.conv3 = nn.Conv1d(12, 15, 3)
        self.norm3=nn.BatchNorm1d(15)
        self.conv4 = nn.Conv1d(10, 10, 5)
        self.norm4=nn.BatchNorm1d(10)
        self.conv1_2 = nn.Conv1d(21, 15, (4,33))
        #self.norm1_2=nn.BatchNorm2d(15)
        self.fc1=nn.Linear(450,200)#150) 
        #self.bn1 = nn.BatchNorm1d(200)
        self.fc2=nn.Linear(200,120)
        #self.bn2 = nn.BatchNorm1d(120)
        self.fc3=nn.Linear(120,8)
        self.fc4=nn.Linear(120,1)
        self.sigmoid=nn.Sigmoid()
        

    def forward(self, x):
        """
        Args:
          x of shape (batch_size, 21, 4, 33): Input sequences.
        
        Returns:
          y of shape (batch_size, 8): Outputs of the network.
        """
        x=self.norm0(x)
        y=F.relu(self.conv1(x)) #(N, C, 1, L), where N is batch size, C is number of channels, L is length after CNN
        y=y.squeeze(dim=2) #(N, C, L)
        #y=self.m(y)
        y=self.norm1(y) #Norm over C dimension of (N, C, L)
        y=F.relu(self.conv2(y))
        #y=self.m(y)
        y=self.norm2(y)
        #y=y.unsqueeze(dim=2)
        y=self.dropout(y)
        y=F.relu(self.conv3(y))
        #y=y.squeeze(dim=2)
        #y=self.m(y)
        #y=self.norm3(y)
        y=self.dropout(y)
        #y=F.relu(self.conv4(y))
        #self.dropout(y)
        y2=F.relu(self.conv1_2(x)).squeeze(dim=2) #(N, C, 1, 1) -> (N, C, 1)
        y=torch.cat((y,y2), dim=2) # (N, C, L+1)
        y=self.norm3(y)
        #y=self.dropout(y)
        y = y.view(-1, self.num_flat_features(y)) #(N, C*(L+1))
        y=F.relu(self.fc1(y))
        y=self.dropout(y)
        y=F.relu(self.fc2(y))
        y=self.dropout(y)
        if self.many_classes:
            y=self.fc3(y)
        #else:
        #    y=self.fc4(y)
        #    y=self.sigmoid(y)
        return y
    
    def num_flat_features(self, x):
        size = x.size()[1:]  # all dimensions except the batch dimension
        num_features = 1
        for s in size:
            num_features *= s
        return num_features
-------------------------------------------------------------------------------------------



------------------------------Created input matrices with script:------------------------------
